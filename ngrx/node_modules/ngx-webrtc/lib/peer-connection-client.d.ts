import { EventEmitter } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { PeerConnectionClientSettings } from './interfaces/peer-connection-client-settings';
import { PeerConnectionClientSignalMessage } from './interfaces/peer-connection-client-signal-message';
import { StreamTrack } from './interfaces/stream-track';
export declare class PeerConnectionClient {
    private startTime;
    private started;
    private isInitiator;
    private hasRemoteSdp;
    private messageQueue;
    private connection;
    private settings;
    private isNegotiating;
    private id;
    private readonly DEFAULT_SDP_OFFER_OPTIONS;
    /**
     * messages send by the peer connection
     */
    signalingMessage: EventEmitter<PeerConnectionClientSignalMessage>;
    /**
     * triggered when new candidate is available initial value is `null`
     */
    seeNewCandidate$: BehaviorSubject<{
        location: string;
        candidate: string;
    } | null>;
    /**
     * triggered when a remote stream is added @deprecated use remoteTrackAdded
     */
    remoteStreamAdded: EventEmitter<StreamTrack>;
    /**
     * triggered when a remote track is added
     */
    remoteTrackAdded: EventEmitter<StreamTrack>;
    /**
     * triggered when the `RTCSignalingState` is changed inital value is `null`
     */
    signalState$: BehaviorSubject<RTCSignalingState | null>;
    /**
     * triggered if an error occure inital value is `null`
     */
    error$: BehaviorSubject<{
        source: string;
        error?: Error | undefined;
    } | null>;
    /**
     * triggered when the connected user toggle share screen, inital value is `false`
     */
    useShareScreen$: BehaviorSubject<boolean>;
    /**
     * triggered when remote description is set, inital value is `null`
     */
    remotesDescriptionSet: BehaviorSubject<MediaStreamTrack | null>;
    /**
     * triggered when connected user close connection
     */
    remoteHangUp: EventEmitter<void>;
    /**
     * triggered when the connected user asks for mute user audio
     */
    muteMyAudio: EventEmitter<void>;
    /**
     * triggered when the connected user asks for mute user video
     */
    muteMyVideo: EventEmitter<void>;
    /**
     * triggered when the connected user mutes his video
     */
    userMuteVideo: EventEmitter<void>;
    /**
     * triggered when the connected user unmutes his video
     */
    userUnmuteVideo: EventEmitter<void>;
    /**
     * triggered when the connected user mutes his audio
     */
    userMuteAudio: EventEmitter<void>;
    /**
     * triggered when the connected user unmutes his audio
     */
    userUnmuteAudio: EventEmitter<void>;
    /**
     * triggerd on need negotiation
     */
    negotiationNeededTriggered: Subject<boolean>;
    /**
     * triggered on I see connection state changed, inital value is `null`
     */
    iceConnectionState$: BehaviorSubject<RTCIceConnectionState | null>;
    constructor(settings: PeerConnectionClientSettings);
    /**
     * Start Peer connection as caller
     * @link https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createOffer
     * @param offerOptions options for the connection
     *
     * @returns `true` when offer is made `false` if no connection available or the connection is already open
     */
    startAsCaller(offerOptions?: RTCOfferOptions): boolean;
    createOffer(offerOptions?: RTCOfferOptions): boolean;
    /**
     * Start Peer connection as callee
     * @param initialMessages messages that are collected before the `PeerConnectionClient` instance is created
     * @returns `true` when messages are queed or processed `false` if no connection available or the connection is already open
     */
    startAsCallee(initialMessages?: string[] | PeerConnectionClientSignalMessage[]): boolean;
    /**
     * send `PeerConnectionClientSignalMessageType.Bye` message to connected user and close the open connection
     */
    close(): void;
    /**
     * send `PeerConnectionClientSignalMessageType.AudioMuted` message to connected user
     */
    audioMuted(): void;
    /**
     * send `PeerConnectionClientSignalMessageType.AudioUnmuted` message to connected user
     */
    audioUnmuted(): void;
    /**
     * send `PeerConnectionClientSignalMessageType.VideoMuted` message to connected user
     */
    videoMuted(): void;
    /**
     * send `PeerConnectionClientSignalMessageType.VideoUnmuted` message to connected user
     */
    videoUnmuted(): void;
    /**
     * send `PeerConnectionClientSignalMessageType.RequestMuteAudio` message to connected user
     */
    requestMuteAudio(): void;
    /**
     * send `PeerConnectionClientSignalMessageType.RequestMuteVideo` message to connected user
     */
    requestMuteVideo(): void;
    /**
     * send `PeerConnectionClientSignalMessageType.StartShareScreen` message to connected user
     */
    startShareScreen(): void;
    /**
     * send `PeerConnectionClientSignalMessageType.StopShareScreen` message to connected user
     */
    stopShareScreen(): void;
    /**
     * get peer connection state
     * @returns `null` if not connected otherwiese an object of `RTCSignalingState`, `RTCIceGatheringState` and `RTCIceConnectionState`
     */
    getPeerConnectionStates(): {
        signalingState: RTCSignalingState;
        iceGatheringState: RTCIceGatheringState;
        iceConnectionState: RTCIceConnectionState;
    } | null;
    /**
     * get the connection stats of a track in the connection
     * @param track `MediaStreamTrack` to check state for
     * @returns Promise that resolves to `RTCStatsReport`
     */
    getPeerConnectionStats(track?: MediaStreamTrack): Promise<RTCStatsReport>;
    /**
     * add a `MediaStreamTrack` to the connection
     * @param track `MediaStreamTrack` to be added to the connection.
     */
    addTrack(track: MediaStreamTrack): void;
    /**
     * replace current `MediaStreamTrack` with new from parameter
     * @param track new `MediaStreamTrack`
     */
    replaceTrack(track: MediaStreamTrack): void;
    /**
     * Add all `MediaStreamTrack`s of a `MediaStream` to the connection
     * @param mediaSteam `MediaStream` with tracks
     */
    addStream(mediaSteam: MediaStream): void;
    private setLocalSdpAndNotify;
    private filterIceCandidate;
    private onIceCandidate;
    private handleMessageEvents;
    /**
     * execute this methode to set messages in the peer connection. You need a connection lay to receive messages.
     * @param message message to process
     */
    receiveSignalingMessage(message: string | PeerConnectionClientSignalMessage): void;
    private processSignalingMessage;
    private doAnswer;
    private setRemoteSdp;
    private drainMessageQueue;
    private onIceConnectionStateChange;
    private onnegotiationneeded;
    private onSignalingStateChange;
    private onError;
    private onRecordIceCandidate;
    private onRemoteTrackAdded;
    private onSetRemoteDescriptionSuccess;
    private log;
    private error;
}
