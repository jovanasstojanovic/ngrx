import { ComponentRef, EventEmitter } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { User } from '../interfaces/user';
import { RemotePeerComponentInterface } from '../interfaces/remote-peer-component-interface';
import { PeerConnectionClient } from '../peer-connection-client';
import { PeerConnectionClientSettings } from "../interfaces/peer-connection-client-settings";
import { UserInCall } from '../interfaces/user-in-call';
import { Configuration } from '../ngx-webrtc-configuration';
import { IceServer } from '../interfaces/ice-server';
import * as i0 from "@angular/core";
/**
 * The CallService holds the state of the peer connection. It provides methods to update the state
 * and methods to create a `PeerConnectionClient`.
 */
export declare class CallService {
    private readonly config;
    private readonly storage;
    constructor(config: Configuration, storage: 'localStorage' | 'sessionStorage');
    private readonly storage_key_since;
    private since;
    private identifier;
    /**
     * users in call state, add user via `CallService.addUser(User,...)` and remove user via `CallService.removeUser(User)`.
     * get all User via `CallService.getUsers()`, get one user via `CallService.getUser()`.
     */
    users$: BehaviorSubject<UserInCall[]>;
    /**
     * Emitted by `ShareScreenDirective` when current User starts sharing his screen.
     */
    startShareScreen: EventEmitter<void>;
    /**
     * Emitted by `ShareScreenDirective` when current User stops sharing his screen.
     */
    stopShareScreen: EventEmitter<void>;
    /**
     * default public and free IceServers list
     * ```json
     * [
     *  { urls: 'stun:stun.l.google.com:19302' },
     *  { urls: 'stun:global.stun.twilio.com:3478?transport=udp' },
     *  { urls: 'stun:stun.services.mozilla.com' },
     * ]
     *
     * ```
     */
    defaultServers: IceServer[];
    /**
     * chat status state
     */
    started$: BehaviorSubject<boolean>;
    /**
     * update since timestamp with current time
     */
    updateSince(): void;
    /**
     * get current since timestamp set by `CallService.updateSince()`
     * @returns Timestamp
     */
    getSince(): number;
    /**
     * The `CallService` hold the users state with all users, with this methode you can add a user to the state.
     * @param user User object that contains userIdentifier
     * @param connection created connection for the user
     * @param node component that is used to display the users webcam, etc.
     */
    addUser(user: User, connection: PeerConnectionClient, node?: ComponentRef<RemotePeerComponentInterface>): void;
    /**
     * remove a user object from state
     * @param user User object to remove
     */
    removeUser(user: User): void;
    /**
     * Use this method if the passed user has a camera to update the state.
     * @param user User to update
     */
    userHasCam(user: User): void;
    /**
     * Use this method if the passed user has a microphone to update the state.
     * @param user
     */
    userHasMic(user: User): void;
    /**
     * Use this method when the passed user deactivates his microphone to update the state.
     * @param user
     */
    userAudioMuted(user: User): void;
    /**
     * Use this method when the passed user activates his microphone to update the state.
     * @param user
     */
    userAudioUnmuted(user: User): void;
    /**
     * Use this method when the passed user deactivates his camera to update the state.
     * @param user
     */
    userVideoMuted(user: User): void;
    /**
     * Use this method when the passed user activates his camera to update the state.
     * @param user
     */
    userVideoUnmuted(user: User): void;
    /**
     * Use this method when the passed user starts to share his screen to update the state.
     * @param user
     */
    userStartShareScreen(user: User): void;
    /**
     * Use this method when the passed user stops sharing his screen to update the state.
     * @param user
     */
    userStopShareScreen(user: User): void;
    /**
     * Give all users who are currently in the state.
     * @returns All users currently in state
     */
    getUsers(): UserInCall[];
    /**
     *
     * @param user User with `userIdentifier`
     * @returns User in state
     */
    getUser(user: User): UserInCall | null;
    /**
     * Create a new `PeerConnectionClient` with the given settings
     * @param settings Settings for creating the `PeerConnectionClient`
     * @returns `PeerConnectionClient` object
     */
    createPeerClient(settings: PeerConnectionClientSettings): Promise<PeerConnectionClient>;
    /**
     * With this methode you can create a RTCCertificate to secure a connection.
     * @link https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/generateCertificate
     * @param algorithm Certificate options used by `RTCPeerConnection.generateCertificate()` Default algorithm `ECDSA` with curve `P-256`
     * @returns Promise resolve to `RTCCertificate`
     */
    createCertifcate(algorithm?: unknown): Promise<RTCCertificate>;
    /**
     * set call state started to `true`, you can subscribe to `CallService.started$` for updates.
     */
    start(): void;
    /**
     * set call state started to `false`, you can subscribe to `CallService.started$` for updates.
     */
    stop(): void;
    /**
     * Configured user identifier.
     * @returns identifier to select a User
     */
    getUserIdentifier(): (keyof User);
    private findUser;
    static ɵfac: i0.ɵɵFactoryDeclaration<CallService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<CallService>;
}
