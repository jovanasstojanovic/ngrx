import { OnDestroy } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { DeviceType } from '../enums';
import { DevicesGroup } from '../interfaces';
import { Configuration } from '../ngx-webrtc-configuration';
import { PreferencesService } from './preferences.service';
import { StreamService } from './stream.service';
import * as i0 from "@angular/core";
/**
 * The DeviceService help you with device interaction (audio and video devices) and can hold a state for devices if you want to implement
 * a lobby with device testing.
 */
export declare class DeviceService implements OnDestroy {
    private readonly config;
    private streamService;
    private preferencesService;
    private storage;
    selectedAudioInput$: BehaviorSubject<MediaDeviceInfo | null>;
    selectedVideoInput$: BehaviorSubject<MediaDeviceInfo | null>;
    devices$: BehaviorSubject<MediaDeviceInfo[]>;
    devicesGoups$: BehaviorSubject<DevicesGroup[]>;
    constructor(config: Configuration, streamService: StreamService, preferencesService: PreferencesService);
    ngOnDestroy(): void;
    private onDeviceChangeListener;
    detectSelectedDevices(): Promise<MediaDeviceInfo[]>;
    getMediaDevicesGrouped(omit?: DeviceType[]): DevicesGroup[];
    /**
     * get media devices, Attention you need getMedia permissions for this call
     * @returns Promise that resolves to media Devices as array
     */
    getMediaDevices(): Promise<MediaDeviceInfo[]>;
    /**
     * Change selected device wit a deviceId and a device type.
     * @param deviceId id of selected device
     * @param kind type of selected device `VideDevice` or `AudioDevice`
     */
    changeSelectedDevice(deviceId: string, kind: DeviceType): Promise<void>;
    /**
     * Check the given device, if it's selected.
     * @param device device to check if it's selected
     * @param kind the kind of the device to check
     * @returns `true` if the devie is selected, outerwise `false`
     */
    isDeviceSelected(device: MediaDeviceInfo, kind: DeviceType): boolean;
    /**
     * group a list of devices you get by calling `StreamService.getMediaDevices()` by type.
     * @param devices list of devices you get by calling `StreamService.getMediaDevices()`
     * @returns a list of devices grouped by `DeviceType`
     */
    groupDeviceByKind(devices: MediaDeviceInfo[], omit?: DeviceType[]): DevicesGroup[];
    /**
     * An simple wrapper for `navigator.mediaDevices.getUserMedia`, with basis error handling.
     * @todo refactor
     * @param mediaConstraints a MediaStreamConstraints e.g. with specific deviceId, resolution or just audio. Default is:
     *                          ```json
     *                         {
     *                             audio: true,
     *                             video: true
     *                         }
     *                         ```
     * @returns Promise that resilve to a stream matching the constraint
     */
    tryGetUserMedia(mediaConstraints?: MediaStreamConstraints): Promise<MediaStream>;
    private findFirstSuccessful;
    tryGetMedia(onSuccess: (arg0: MediaStream) => void, onNotFound: () => void): void;
    private tryGetMediaWithPreferences;
    private tryGetMediaDefault;
    private tryGetMediaAudioOnly;
    private setDeviceAndResolve;
    static ɵfac: i0.ɵɵFactoryDeclaration<DeviceService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<DeviceService>;
}
